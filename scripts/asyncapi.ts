import {
  ConstrainedDictionaryModel,
  PYTHON_PYDANTIC_PRESET,
  PythonGenerator,
} from '@asyncapi/modelina'
import fs from 'node:fs'
import path from 'node:path'

const CUSTOM_PYDANTIC_PRESET = {
  class: {
    ...PYTHON_PYDANTIC_PRESET.class,
    property({ property, model, renderer }) {
      let type = property.property.type
      const propertyName = property.propertyName
      const isOptional = !property.required || property.property.options.isNullable === true

      if (isOptional) {
        type = `Optional[${type}]`
      }

      if (property.property.options.const) {
        renderer.dependencyManager.addDependency('from typing import Literal')
        type = `Literal['${property.property.options.const.originalInput}']`
      }

      type = renderer.renderPropertyType({
        modelType: model.type,
        propertyType: type,
      })

      const decoratorArgs = []

      if (property.property.originalInput.description) {
        decoratorArgs.push(`description='''${property.property.originalInput.description}'''`)
      }

      // Fix: Check for default value in originalInput
      const defaultValue = property.property.originalInput.default
      if (defaultValue !== undefined) {
        if (typeof defaultValue === 'string') {
          decoratorArgs.push(`default='${defaultValue}'`)
        } else {
          decoratorArgs.push(`default=${defaultValue}`)
        }
      } else if (isOptional) {
        decoratorArgs.push('default=None')
      }

      if (property.property.options.const) {
        let value = property.property.options.const.value
        if (model.options.discriminator?.discriminator === property.unconstrainedPropertyName) {
          value = property.property.options.const.originalInput
        }
        decoratorArgs.push(`default='${value}'`)
        decoratorArgs.push('frozen=True')
      }

      if (
        property.property instanceof ConstrainedDictionaryModel &&
        property.property.serializationType === 'unwrap'
      ) {
        decoratorArgs.push('exclude=True')
      }

      if (
        property.propertyName !== property.unconstrainedPropertyName &&
        (!(property.property instanceof ConstrainedDictionaryModel) ||
          property.property.serializationType !== 'unwrap')
      ) {
        decoratorArgs.push(`alias='''${property.unconstrainedPropertyName}'''`)
      }

      return `${propertyName}: ${type} = Field(${decoratorArgs.join(', ')})`
    },
  },
}

const generator = new PythonGenerator({
  presets: [CUSTOM_PYDANTIC_PRESET],
})
const inputPath = path.resolve(import.meta.dir, '../asyncapi.json')
const outputDir = path.resolve(import.meta.dir, '../../backend/src/curator/asyncapi')

async function generate() {
  const content = fs.readFileSync(inputPath, 'utf8')
  const document = JSON.parse(content)

  const models = await generator.generate(document)
  const modelNames = models.map((m) => m.modelName).filter((name) => name && name.trim() !== '')

  if (fs.existsSync(outputDir)) {
    fs.rmSync(outputDir, { recursive: true, force: true })
  }
  fs.mkdirSync(outputDir, { recursive: true })

  for (const model of models) {
    if (!model.modelName || model.modelName.trim() === '') {
      continue
    }
    let code = model.result
    // Workaround for Modelina's Pydantic preset issue where unwrap_additional_properties
    // assumes input is always a dict or model instance. When validating Unions containing
    // primitives, this validator receives the primitive value, causing an AttributeError
    // on .model_dump(). We catch this to allow Pydantic to handle the type mismatch naturally.
    code = code.replace(
      /if not isinstance\(data, dict\):\s+data = data\.model_dump\(\)/g,
      'if not isinstance(data, dict):\n            try:\n                data = data.model_dump()\n            except AttributeError:\n                return data',
    )

    // Fix double quoting issue for const fields
    code = code.replace(/default=''(.*?)''/g, "default='$1'")

    const imports = new Set(model.dependencies || [])

    // Find model dependencies
    const referencedModels = modelNames.filter(
      (name) => name !== model.modelName && new RegExp(`\\b${name}\\b`).test(code),
    )

    const modelImports = referencedModels.map((name) => `from .${name} import ${name}`)

    const fileContent = [
      '# Generated by @asyncapi/modelina',
      '# Do not edit manually',
      '',
      ...Array.from(imports),
      ...modelImports,
      '',
      code,
    ].join('\n')

    fs.writeFileSync(path.join(outputDir, `${model.modelName}.py`), fileContent)
  }

  // Generate __init__.py
  const initContent = [
    '# Generated by @asyncapi/modelina',
    '# Do not edit manually',
    '',
    ...modelNames.map((name) => `from .${name} import ${name}`),
    '',
    // We don't need to rebuild explicitly if we use imports, but to be safe for recursive refs:
    '# Rebuild models to resolve forward references',
    'from pydantic import BaseModel',
    'for name, cls in list(globals().items()):',
    '    if isinstance(cls, type) and issubclass(cls, BaseModel) and cls is not BaseModel:',
    '        try:',
    '            cls.model_rebuild()',
    '        except Exception:',
    '            pass',
  ].join('\n')

  fs.writeFileSync(path.join(outputDir, '__init__.py'), initContent)
  console.log(`Generated Python models to ${outputDir}`)
}

generate().catch(console.error)
